{{- if .Values.vaultAutoUnseal.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-auto-unseal
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "0"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  backoffLimit: 5
  template:
    metadata:
      labels:
        app: vault-auto-unseal
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      containers:
        - name: vault-auto-unseal
          image: bitnami/kubectl:latest
          env:
            - name: VAULT_ADDR
              value: "http://vault.{{ .Release.Namespace }}.svc:8200"
            - name: SECRET_NAME
              value: {{ .Values.vaultAutoUnseal.secretName | quote }}
            - name: NAMESPACE
              value: {{ .Release.Namespace }}
            - name: KEY_SHARES
              value: {{ .Values.vaultAutoUnseal.keyShares | quote }}
            - name: KEY_THRESHOLD
              value: {{ .Values.vaultAutoUnseal.keyThreshold | quote }}
            - name: VAULT_POD
              value: "vault-0"
          command:
            - /bin/sh
            - -ec
            - |
              # Helper: run vault commands via kubectl exec
              vexec() {
                kubectl exec -n "${NAMESPACE}" "${VAULT_POD}" -- \
                  env VAULT_ADDR=http://127.0.0.1:8200 vault "$@"
              }

              # Wait for vault-0 pod to be running (not Ready — it won't be ready until unsealed)
              echo "Waiting for ${VAULT_POD} to be running..."
              while true; do
                PHASE=$(kubectl get pod -n "${NAMESPACE}" "${VAULT_POD}" -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
                if [ "$PHASE" = "Running" ]; then
                  break
                fi
                echo "Pod phase: ${PHASE:-not found}, retrying in 5s..."
                sleep 5
              done

              # Wait for Vault to respond (sealed or uninitialized counts as responding)
              echo "Waiting for Vault to be reachable..."
              while true; do
                rc=0
                vexec status -format=json >/dev/null 2>&1 || rc=$?
                # 0 = unsealed, 2 = sealed/uninitialized but reachable
                if [ "$rc" -eq 0 ] || [ "$rc" -eq 2 ]; then
                  break
                fi
                echo "Vault not reachable (rc=$rc), retrying in 5s..."
                sleep 5
              done

              # Get vault status via text output (more reliable to parse than JSON via exec)
              INITIALIZED="unknown"
              SEALED="unknown"
              rc=0
              vexec status >/dev/null 2>&1 || rc=$?
              if [ "$rc" -eq 0 ]; then
                INITIALIZED="true"
                SEALED="false"
              elif [ "$rc" -eq 2 ]; then
                # rc=2 means sealed or uninitialized — check init status
                STATUS_TEXT=$(vexec status 2>&1 || true)
                echo "Status output: ${STATUS_TEXT}"
                if echo "$STATUS_TEXT" | grep -q "Vault is not initialized"; then
                  INITIALIZED="false"
                  SEALED="true"
                else
                  INITIALIZED="true"
                  SEALED="true"
                fi
              fi

              echo "Vault status: initialized=${INITIALIZED}, sealed=${SEALED}"

              # Check if unseal keys secret already exists
              HAS_SECRET="false"
              if kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" >/dev/null 2>&1; then
                HAS_SECRET="true"
              fi

              # --- INIT if needed ---
              if [ "$INITIALIZED" = "false" ]; then
                echo "Vault is not initialized. Initializing with ${KEY_SHARES} shares, threshold ${KEY_THRESHOLD}..."
                INIT_OUTPUT=$(vexec operator init \
                  -key-shares="${KEY_SHARES}" \
                  -key-threshold="${KEY_THRESHOLD}" \
                  -format=json)

                echo "Init completed."

                # Write init output to a temp file for reliable parsing
                TMPFILE=$(mktemp)
                echo "$INIT_OUTPUT" > "$TMPFILE"

                # Extract root_token — search for the line with "root_token"
                ROOT_TOKEN=$(sed -n 's/.*"root_token"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' "$TMPFILE")
                echo "Root token extracted: [${ROOT_TOKEN:+OK}]"

                if [ -z "$ROOT_TOKEN" ]; then
                  echo "ERROR: Failed to extract root token from init output."
                  echo "Raw output:"
                  cat "$TMPFILE"
                  rm -f "$TMPFILE"
                  exit 1
                fi

                # Extract unseal keys — look for lines between "unseal_keys_b64" and "]"
                # Each key is on its own line as "  \"<key>\""
                UNSEAL_KEYS=$(sed -n '/"unseal_keys_b64"/,/\]/p' "$TMPFILE" | sed -n 's/.*"\([A-Za-z0-9+/=]\{10,\}\)".*/\1/p')
                echo "Unseal keys extracted: $(echo "$UNSEAL_KEYS" | wc -l | tr -d ' ') keys"

                if [ -z "$UNSEAL_KEYS" ]; then
                  echo "ERROR: Failed to extract unseal keys from init output."
                  echo "Raw output:"
                  cat "$TMPFILE"
                  rm -f "$TMPFILE"
                  exit 1
                fi

                rm -f "$TMPFILE"

                if [ "$HAS_SECRET" = "true" ]; then
                  echo "Deleting old secret ${SECRET_NAME}..."
                  kubectl delete secret -n "${NAMESPACE}" "${SECRET_NAME}"
                fi

                # Build and create the secret with individual --from-literal args
                CREATE_CMD="kubectl create secret generic ${SECRET_NAME} -n ${NAMESPACE} --from-literal=root-token=${ROOT_TOKEN}"
                i=0
                for KEY in ${UNSEAL_KEYS}; do
                  CREATE_CMD="${CREATE_CMD} --from-literal=unseal-key-${i}=${KEY}"
                  i=$((i+1))
                done

                echo "Creating K8s secret ${SECRET_NAME}..."
                eval ${CREATE_CMD}

                echo "Vault initialized. Keys stored in secret ${NAMESPACE}/${SECRET_NAME}."
                SEALED="true"
                HAS_SECRET="true"
              fi

              # --- UNSEAL if needed ---
              if [ "$SEALED" = "true" ]; then
                echo "Vault is sealed. Unsealing..."

                if [ "$HAS_SECRET" = "false" ]; then
                  echo "ERROR: Vault is sealed but no unseal keys found in secret ${NAMESPACE}/${SECRET_NAME}."
                  echo "Please unseal Vault manually or delete the Vault PVC and re-deploy."
                  exit 1
                fi

                i=0
                while [ $i -lt ${KEY_THRESHOLD} ]; do
                  JSONPATH=".data.unseal-key-${i}"
                  KEY=$(kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" -o jsonpath="{${JSONPATH}}" | base64 -d)
                  echo "Applying unseal key $((i+1))/${KEY_THRESHOLD}... key length: ${#KEY}"
                  if [ -z "$KEY" ]; then
                    echo "ERROR: Unseal key ${i} is empty. Secret may be corrupted."
                    echo "Delete secret ${SECRET_NAME} and Vault PVC, then re-deploy."
                    exit 1
                  fi
                  # Pass key as argument via env var to avoid shell escaping issues
                  kubectl exec -n "${NAMESPACE}" "${VAULT_POD}" -- \
                    env VAULT_ADDR=http://127.0.0.1:8200 UNSEAL_KEY="$KEY" \
                    sh -c 'vault operator unseal "$UNSEAL_KEY"'
                  i=$((i+1))
                done

                echo "vault-0 unsealed successfully."
              else
                echo "Vault is already unsealed."
              fi

              # --- Store root token in vault-root-token secret for other Jobs ---
              ROOT_TOKEN=$(kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" -o jsonpath="{.data.root-token}" 2>/dev/null | base64 -d 2>/dev/null || echo "")
              if [ -n "$ROOT_TOKEN" ]; then
                if kubectl get secret -n "${NAMESPACE}" vault-root-token >/dev/null 2>&1; then
                  kubectl patch secret -n "${NAMESPACE}" vault-root-token \
                    -p "{\"stringData\":{\"token\":\"${ROOT_TOKEN}\"}}"
                  echo "Updated vault-root-token secret."
                else
                  kubectl create secret generic vault-root-token -n "${NAMESPACE}" \
                    --from-literal=token="${ROOT_TOKEN}"
                  echo "Created vault-root-token secret."
                fi
              fi

              echo "Vault auto-unseal complete!"
{{- end }}
